# TypeScript
TypeScript 是js的超集，是一个可选的，静态的类型系统
- 类型系统
对代码中所有的标识符(变量，函数，参数，返回值)进行类型检查
- 可选的(在运行之前)
无论是浏览器环境，还是node环境，都无法识别ts代码
tsc  ts --> es
静态：类型检查发生的时间，在编译的时候，而非运行时
ts不参与任何运行时的类型检查

**TS常识**
- 2012 微软发布   (ES6,2015发布)
- Anders Hejlsberg 负责开发TS项目
- 开源  拥抱ES标准
- 3.4 版本  中文网3.1  个人翻译


# 在node环境中搭建TS开发环境

# 安装TypeScript
npm install -g typescript

默认情况下，TS会做出下面几种假设：
1.假设当前的执行环境是浏览器环境，
2.如果代码 中没有使用模块化语句(import export),便认为该代码是全局执行
3.编译的目标代码是ES3   做到最大兼容

有两种方式更改以上假设
1.使用tsc命令行的时候，加上选项参数
2.使用ts配置文件，更改编译选项(常用)

# TS配置文件
可以手动新建 tsconfig.json
也可以输入命令 tsc --init 自动生成

使用了配置文件后，使用tsc进行编译时，不能跟上文件名，如果跟上文件名，会忽略配置文件，直接输入tsc就ok  默认会找到所有文件下的所有ts文件全部进行编译
需要进行配置只编译src文件夹下的ts文件

第三方库  @types/node
@types是一个ts官方的类型库，其中包括的很多对js代码的类型描述
npm i -D @types/node  开发环境下安装

# 使用第三方库简化流程
ts-node:将ts代码在内存中完成编译，同时完成运行 npm i -g ts-node  可使用ts-node命令   ts-node src/index.ts

nodemon:用于检测文件的变化 npm i -g nodemon
nodemon --exec ts-node src/index.ts  可将次代码写到package.json文件中
然后执行 npm run dev就ok   nodemon -e -ts  表示只监测ts文件变化会重新编译
nodemon --watch src 表示只监控src文件夹中的文件变化
全部开发完成之后，可执行tsc命令全部打包


# 基本类型约束
> TS是一个可选的静态的类型系统
# 如何进行类型约束
仅需要在变量，函数的参数，函数的返回值位置加上  :类型  就好
ts在很多场景中可以完成类型推导
当名称下面有三个点，是any：表示任意类型，对该类型ts不进行类型检查

>小技巧，如何区分数字字符串和数字(类似于手机号)，关键看怎么读
>如果按照数字的方式读，则为数字，否则为字符串

# 源代码和编译结果的差异
编译结果中没有类型约束信息

# 基本类型
- numbet:数字
- string
- boolean
- 数组
- object
- null 和 undefined
null和 undefined是所有其他类型的子类型，他们可以赋值给其他类型
通过设置"strictNullChecks": true 避免这种情况发生

# 其他常用类型
- 联合类型
多种类型任选其一 配合类型保护进行判断
- void类型
通常用于约束函数的返回值，表示该函数没有任何返回
- never类型
通常用于约束函数的返回值，表示该函数永远不会结束  用于抛出错误
- 字面量类型
使用一个值进行约束
- 元祖类型(Tuple)
一个固定长度的数组，并且数组中每一项的确定
- any类型
any类型可以绕过类型检查，因此，any类型的数据可以赋值个任意类型  不建议使用

# 类型别名
对已知的一些类型定义名称   type 类型名 = ...

# 函数的相关约束
函数重载：在函数实现之前，对函数调用的多种情况进行声明
可选参数：可以在某些参数名后面加上问号，表示该参数可以不用传递，可选参数必须在参数列表末尾

# 扩展类型-枚举
> 扩展类型：类型别名，枚举，接口，类
枚举通常用于约束某个变量的取值范围,字面量和联合类型配合使用，也能达到这种效果

# 字面量类型的问题
- 在类型约束位置，会产生重复代码，可以使用类型别名解决
- 逻辑含义和真是的值产生了混淆，会导致当修改真实值的时候，产生大量的修改
- 字面量类型不会进入到编译结果

# 枚举
如何定义一个枚举：
enum  枚举名{}
    枚举字段1，
    枚举字段2，
}
枚举会出现在编译结果中，编译结果中变现为对象
枚举的规则：
- 枚举的字段值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量，可以直接赋值为数字
- 数字枚举的编译结果和字符串枚举有差异
最佳实践
- 尽量不要在一个枚举中即出现字符串字段，又出现数字字段
- 使用枚举时，尽量使用枚举字段的名称，而不使用真实的值

## 扩展知识：位枚举(枚举的位运算)
针对的时数字枚举
位运算：两个数字换算成二进制后进行的运算

# 模块化
配置名称               含义
module                设置编译结果中使用的模块化标准
moduleResolution      设置解析模块的模式
noImpLicitUseStrict   编译结果中不包含'use strict'
removeComments        编译结果移除注释
noEmitOnError         错误时不生成编译结果
esModuleInterop       启用es模块化交互非es模块导出

> 前端领域中的模块化标准：ES6 commonjs  amd cmd
> TS中如何书写模块化语句
> 编译结果
在padcage.json中配置"build": "rd /s /q dist & tsc"  编译时先删除dist文件夹，在生成dist文件夹
# TS中如何书写模块化语句
TS中，导入和导出模块，统一使用ES6的模块化标准

# 编译结果中的模块化
可配置    tsc --watch
- 如果编译结果的模块化标准是ES6,没有区别
- 如果编译结果的模块化标准是commonjs,导出的声明会变成exports的属性，
默认的导出会变成exports的default属性

# 如何在ts中书写commonjs模块化代码
导出：export =xxx
导入：import xxx = require("xxx")

#模块解析
模块解析：应该从什么位置寻找模块
TS中，有两种模块解析策略
- classic:经典
- node:node解析策略(唯一的变化，是将js替换为ts)

# 扩展类型  接口
 扩展类型 类型别名 枚举 接口 类
 TypeScript的接口：用于约束类，对象，函数的契约(标准)
  契约(标准)的形式：
  - API文档，弱标准
  - 代码约束，强标准
  
  和类型别名一样，不出现在编译结果中
  
  1.接口约束对象
  2.接口约束函数
  
接口可以继承
可以通过接口之间的继承，实现多种接口的组合
使用类型别名可以实现类似的组合效果，需要通过```&```，他叫做交叉类型

他们的区别：
- 子接口不能覆盖父接口的成员
- 交叉类型会把相同成员的类型进行交叉

#readonly  修饰符
只读修饰符  修饰的目标是只读的    只读修饰符不在编译结果中   类型别名与接口中均可使用

#类型兼容性
B -> A 如果能完成赋值，则B和A类型兼容
鸭子辨型法（子结构辨型法）: 目标类型需要某一特征，赋值的类型只要能满足该特征即可
- 基本类型：完全匹配
- 对象类型：鸭子辨型法
类型断言  as 具体类型
当使用对象字面量直接赋值的时候，是使用更加严格的判断
- 函数类型
1.参数:传递给目标函数的参数可以少，不可以多
2.返回值：要求返回的必须返回；不要求返回随意

#TS中的类
属性：使用属性列表来描述类中的属性
属性初始化检查：    "strictPropertyInitialization": true 
属性初始化位置：
1.构造函数中
2.属性默认值
属性可以修饰为可选的
属性可以修饰为只读的
使用访问修饰符可以控制类中的某个成员的某个权限
1.public   默认的访问修饰符，公开的，所有代码均可访问
2.private 私有的，只有在类中可以使用
3.protected 
属性简写：如果某个属性，通过构造函数的参数传递，并且不做任何处理，赋值给该属性，可以进行简写（必须添加修饰符）

访问器
作用：用于控制属性的读取和赋值

#泛型
有时书写某个函数时，会丢失一些类型信息(多个位置的类型应该保持一致或有关联的信息)
泛型：是指附属于函数、类、接口、类型别名之上的类型
泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型，可以用该变量来代替，只有到调用时，才能确定他的类型
很多时候，TS会智能的根据传递的参数，推导出泛型的具体类型
如果无法完成推到，并且又没有传递具体的类型，默认为空对象   泛型可以设置默认值
#在函数中使用泛型
在函数名之后写上```<泛型名称>```

#如何在类型别名、接口、类中使用泛型
直接在名称后写上```<泛型名称>```

#泛型约束    
用于限制泛型的取值

#多泛型




























