# 深入理解类和接口
# 面向对象概述
##  为什么讲面向对象
1. TS为前端面向对象带来的契机
JS语言没有类型检查，如果使用面向对象的方式开发，会产生大量的接口，而大量的接口会导致调用复杂度剧增，这种复杂度必须通过严格的类型检查来避免错误，尽管可以使用注释或文档或记忆力，但是他们没有强约束力

TS带来了完整的类型系统，因此开发复杂程序时，无论接口数量有多少，都可以获得完整的类型检查，并且这种检查是具有强约束力的。

2. 面向对象中有许多非常成熟的模式，能处理复杂问题
在过去很多年中，在大型应用或复杂领域，面向对象已经积累了非常多的经验。

## 什么是面向对象
面向对象：Oriented Object,
- 是一种编程思想，它提出一切以类为切入点思考问题。
其他编程思想：面向过程：以功能流程为思考切入点
函数式编程：以数学运算为思考切入点

面向对象：以划分类为思考切入点，类是最小的功能单元

# 类的继承
## 继承的作用
继承可以描述类与类之间的关系

## 成员的重写
重写：子类中覆盖父类的成员。
子类成员不能改变父类成员的类型。
无论是属性还是方法，子类都可以对父类的相应成员进行重写，但是重写是，需要保证类型的匹配。
注意this关键字：在继承关系中，this的指向是动态调用方法时，根据具体的调用者确定this指向。
super关键字：在子类的方法中，可以使用super关键字读取父类成员。

## 类型匹配
鸭子辨型法
子类的对象，始终可以赋值给父类
面向对象中，这种现象叫做里氏替换原则
如果需要判断一个数据的具体的子类类型，可以使用instanceof

## protected修饰符
readonly：只读修饰符
访问权限修饰符：private public protected
protected:受保护的成员，只能在自身和子类中访问

## 单根性和传递性
单根性：每个类最多只能拥有一个父类
传递性：如果A是B的父类，并且B是C的父类，则可认为A也是C的父类。

# 抽象类
## 为什么要使用抽象类
有时某个类只表示一个抽象概念，主要用于提取子类共有的成员，而不能直接创建它的对象。该类可以作为抽象类。
给类前面加上```abstract```，表示该类是一个抽象类，不可以创建一个抽象类对象。

## 抽象成员
父类中，可能知道有些成员是必须存在的，但是不知道该成员的值或实现什么，因此，需要有一种强约束，让继承该类的子类，必须实现该成员。

**抽象类中**，可以有抽象成员，这些抽象成员必须在子类中实现。

## 设计模式 - 模板模式
设计模式：面对一些常见的功能场景，有一些固定的，经过多年实践的成熟方法，这些方法称之为设计模式。

模板模式：有些方法，所有的子类实现的流程完成一直，只是流程中的某个步骤的具体实现不一致，可以将该方法提取到父类，在父类中完成整个流程的实现，遇到实现不一致的方法时，将该方法做成抽象法法。

# 静态成员

## 什么是静态成员
静态成员是指附着在类上的成员。（在JS中，属于某个构造函数的成员）
使用static修饰的成员，是静态成员。
实例成员：对象成员，属于某个类的对象。
静态成员：非实例成员，属于某个类。

## 静态方法中的this
实例方法中的this指向的是**当前对象**
而静态方法中的this指向的是**当前类**

## 设计模式 - 单例模式
单例模式：某些类的对象，在系统中最多只能有一个，为了避免开发者造成随意创建多个类对象的错误，可以使用单例模式进行强约束。

# 在谈接口
接口用于约束类，对象，函数，是一个类型契约。

例题：
> 有一个马戏团，马戏团中有很多动物，包括：狮子，老虎，猴子，狗，这些动物都具有共同的特点：名字，年龄，种类名称，还包含一个共同的方法：打招呼，
> 他们各自有各自的技能，技能是可以通过训练改变的。 狮子和老虎进行火圈表演，猴子进行平衡表演，狗进行智慧表演。

> 马戏团中有一下常见的技能：
> - 火圈表演：单火圈，双火圈
> - 平衡表演：独木桥，走钢丝
> - 智慧表演：算术题，跳舞

不使用接口实现时：
- 对能力（成员函数）没有强约束力
- 容易将类型和能力耦合在一起

系统中缺少对能力的定义 - 接口
面向对象领域中的接口的语义：表达了某个类是否拥有某种能力

某个类具有某种能力，其实就是实现了某种接口

类型保护函数:通过调用该函数，会触发TS的类型保护，改函数必须返回boolean

接口和类型别名的最大区别：接口可以被类实现，而类型别名不可以

> 接口可以继承类，表示该类的所有成员都在接口中。

# 索引器
```obj[值]```成员表达式
在TS中，默认情况下，不对索引器(成员表达式)做严格的类型检查
使用配置```noImpLicitAny```开启对隐式any的检查。
隐式any:TS根据实际情况推导出的any类型。
在索引器中，键的类型可以是字符串，也可以是数字。
在类中，索引器书写的位置应该是所有成员之前。

TS中索引器的作用
- 在严格的检查下，可以实现为类动态增加成员
- 可以实现动态的操作类成员

在JS中，所有的成员本质上都是字符串，如果使用数字作为成员名，会自动转换为字符串。
在TS中，如果某个类中使用了两种类型的索引器，要求两种索引器的值类型必须匹配。

# this指向约束
https://yehudakatz.com/2011/08/10/understanding-javascript-function-invocation-and-this/

## 在JS中this指向的几种情况
明确：大部分时候，this的指向取决于函数的调用方式
- 如果直接调用函数（全局调用），this指向全局对象或undefined（严格模式）
- 如果使用```对象.方法```调用，this指向对象本身
- 如果是dom事件的处理函数，this指向事件处理对象

特殊情况
- 箭头函数，this在函数声明时确定指向，指向函数位置的this。
- 使用bind，apply，call手动绑定this对象

## TS中的this
配置noImplicitThis为true，表示不允许this隐式的指向any

在TS中，允许在书写函数时，手动声明该函数中this的指向，将this作为函数的第一个参数，该参数只用于约束this，并不是真正的参数，
也不会出现在编译结果中。

# 装饰器

## 概述

> 面向对象的概念（Java：注解，c#:特征），decorator
> react中用到

## 解决的问题

装饰器，能够带来额外的信息量，可以达到分离关注点的目的。
- 关注点的问题：在定义某个东西时，应该最清楚该东西的情况。   信息书写位置问题。
- 重复代码的问题。

上述两个问题产生的根源：某些信息在定义时，能够附加的信息量有限。

装饰器的作用：为某些属性、类、参数、方法提供元数据信息。

元数据：描述数据的数据。

### 装饰器的本质

在JS中，装饰器是一个函数。（装饰器是要参与运行的）

## 类装饰器

类装饰器的本质是一个函数，该函数接收一个参数，表示类本身（构造函数本身）

使用装饰器```@得到一个函数```

在TS中，如果约束一个变量为类

- Function
- ```new (参数)=>object```

在TS中要使用装饰器，需要开启```experimentalDecorators```

装饰器函数的运行时间：在类定义后直接运行

类装饰器可以具有返回值：

- void:仅运行函数
- 返回一个新的类，会将新的类替换到装饰目标

多个装饰器的情况：

- 会按照后加入先调用的顺序进行调用。




## 成员装饰器

- 属性
属性装饰器也是一个函数，该函数需要两个参数：
1.如果是静态属性，则为类本身；如果是实例属性，则为类的原型
2.固定为一个字符串，表示属性名

- 方法
属性装饰器也是一个函数，该函数需要三个参数：
1.如果是静态方法，则为类本身；如果是实例方法，则为类的原型
2.固定为一个字符串，表示方法名
3.属性描述对象

都可以有多个装饰器修饰

## 练习：类和属性的描述装饰器

- 无论什么装饰器,只要在创建时就会运行，不管是否产生对象

## reflect-metadata库
该库的作用：保存元数据

## class-validator 和 class-transformer 库

class-transformer 把一个平面对象装换为类的对象

## 补充

- 参数装饰器

依赖注入

要求函数有三个参数：

1.如果方法是静态的，则为类本身；如果方法是实例方式，则为类的原型
2.方法名称
3.在参数列表中的索引

- 关于TS自动注入的元数据

了解

- AOP

编程方式，属于面向对象开发。

将一些在业务中共同出现的功能块，横向切分，以达到分离关注点的目的。

# 类型演算

> 根据已知的信息，计算出新的类型

## 三个关键字

- typeof

ts中的typeof，书写的位置在类型约束的位置上。
表示：获取某个数据的类型。
当typeof作用于类的时候，得到的类型是该类的构造函数

- keyof 

作用于类，接口，类型别名，用于获取其他类型中的所有成员名组成的联合类型。

- in

该关键字往往和keyof联用，限制某个索引类型的取值范围。

## TS中预设的类型演算

```ts

Partial<T>      //将类型T中的成员变为可选

Required<T>     //将类型T中的成员变为必填

Readonly<T>     //将类型T中的成员变为只读

Extract<T,U>    //从T中剔除可以赋值给U的类型

MonNullable<T>  //从T中剔除null和undefined。

ReturnType<T>   //获取函数返回值类型。

InstanceType<T> //获取构造函数类型的实例类型

```


# 声明文件

> 概述、编写、发布

## 概述

1. 什么是声明文件？

以```.d.ts```结尾的文件

2. 声明文件有什么作用？

为JS代码提供类型声明

3. 声明文件的位置

- 放置到tsconfig.json配置中包含的目录中   
- 放置到node_modules/@types文件夹中
- 手动配置
- 与JS代码所在目录相同，并且文件名也相同的文件。用ts代码书写的工程发布之后的格式。

## 编写

> 手动编写  自动生成

- 自动生成

工程是使用ts开发的，发布（编译）之后，是js文件，发布的是js文件。

如果发布的文件，需要其他开发者使用，可以使用声明文件，来描述发布结果中的类型。

配置```tsconfig.json```中的```declaration:true```即可

- 手动编写

1. 对已有库，它是使用js书写而成，并且更改该库的代码为ts成本较高，可以手动编写声明文件

2. 对一些第三方库，它们使用js书写而成，并且这些第三方库没有提供声明文件，可以手动编写声明文件。



**全局声明**

声明一些全局的对象、属性、变量

> namespace: 表示命名空间，可以将其认为是一个对象，命名空间中的内容，必须通过```命名空间.成员名```访问

**模块声明**

**三斜线指令**

在一个声明文件中，包含另一个声明文件

## 发布 

1. 当前工程使用ts开发

编译完成后，将编译结果所在文件夹直接发布到npm上即可

2. 为其他第三方库开发的声明文件

发布到@types/**中。

1） 进入github的开源项目：https://github.com/DefinitelyTyped/DefinitelyTyped

2） fork到自己的开源库中

3） 从自己的开源库中克隆到本地

4） 本地新建分支（例如：mylodash4.3），在新分支中进行声明文件的开发

    在types目录中新建文件夹，在新的文件夹中开发声明文件

5） push分支到你的开源库

6） 到官方的开源库中，提交pull request

7） 等待官方管理员审核（1天）

审核通过之后，会将你的分支代码合并到主分支，然后发布到npm。

之后，就可以通过命令```npm install @types/你发布的库名```
